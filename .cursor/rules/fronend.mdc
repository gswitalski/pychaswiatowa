---
alwaysApply: false
---
## FRONTEND

### Guidelines for ANGULAR

#### ANGULAR_CODING_STANDARDS

- Use standalone components, directives, and pipes instead of NgModules
- Implement signals for state management instead of traditional RxJS-based approaches
- Use the new inject function instead of constructor injection
- Implement control flow with @if, @for, and @switch instead of *ngIf, *ngFor, etc.
- Leverage functional guards and resolvers instead of class-based ones
- Use the new deferrable views for improved loading states
- Implement OnPush change detection strategy for improved performance
- Use TypeScript decorators with explicit visibility modifiers (public, private)
- Leverage Angular CLI for schematics and code generation
- Implement proper lazy loading with loadComponent and loadChildren
- always use 'pych' prefix for comoponents selector

#### ANGULAR_MATERIAL

- Create a dedicated module for Angular Material imports to keep the app module clean
- Use theme mixins to customize component styles instead of overriding CSS
- Implement OnPush change detection for performance critical components
- Leverage the CDK (Component Development Kit) for custom component behaviors
- Use Material's form field components with reactive forms for consistent validation UX
- Implement accessibility attributes and ARIA labels for interactive components
- Use the new Material 3 design system updates where available
- Leverage the Angular Material theming system for consistent branding
- Implement proper typography hierarchy using the Material typography system
- Use Angular Material's built-in a11y features like focus indicators and keyboard navigation
- For colors use Angular Materials SCSS variables eg. --mat-sys-background instead of custom colors when it is possible and reasonable

#### NGRX

- Use the createFeature and createReducer functions to simplify reducer creation
- Implement the facade pattern to abstract NgRx implementation details from components
- Use entity adapter for collections to standardize CRUD operations
- Leverage selectors with memoization to efficiently derive state and prevent unnecessary calculations
- Implement @ngrx/effects for handling side effects like API calls
- Use action creators with typed payloads to ensure type safety throughout the application
- Implement @ngrx/component-store for local state management in complex components
- Use @ngrx/router-store to connect the router to the store
- Leverage @ngrx/entity-data for simplified entity management
- Implement the concatLatestFrom operator for effects that need state with actions

#### LOADING_STATES_AND_SORTING

- Use `state.update()` instead of `state.set()` when updating data after loading to prevent white flashing
- Never use white semi-transparent backgrounds `rgba(255, 255, 255, 0.6)` in loading overlays
- Use `opacity: 0.5` on data containers during loading, not white overlay backgrounds
- Avoid `::after` pseudo-elements with white backgrounds on loading containers
- Keep previous data visible while loading new data to ensure smooth transitions

#### API_COMMUNICATION_AND_DATA_ACCESS

**KRYTYCZNE: Frontend NIGDY nie powinien bezpośrednio operować na danych w Supabase**

##### Dozwolone Użycie SupabaseService w Frontendzie:

✅ **TYLKO te operacje są dozwolone:**
1. **Autentykacja** - `supabase.auth.signIn()`, `supabase.auth.signUp()`, `supabase.auth.signOut()`, `supabase.auth.getUser()`, `supabase.auth.getSession()`
2. **Wywołania Edge Functions** - `supabase.functions.invoke('function-name', { method: 'GET/POST/PUT/DELETE' })`
3. **Storage (upload/download)** - `supabase.storage.from('bucket').upload()`, `supabase.storage.from('bucket').download()`

##### ❌ ZABRONIONE Operacje w Frontendzie:

**NIGDY nie używaj w serwisach frontendowych:**
- ❌ `supabase.from('table_name')` - bezpośrednie zapytania do tabel
- ❌ `supabase.from('table_name').select()` - SELECT bezpośrednio z frontendu
- ❌ `supabase.from('table_name').insert()` - INSERT bezpośrednio z frontendu
- ❌ `supabase.from('table_name').update()` - UPDATE bezpośrednio z frontendu
- ❌ `supabase.from('table_name').delete()` - DELETE bezpośrednio z frontendu
- ❌ `supabase.from('table_name').upsert()` - UPSERT bezpośrednio z frontendu
- ❌ `supabase.rpc()` - wywołania funkcji RPC z frontendu (użyj Edge Functions zamiast tego)

##### ✅ Prawidłowy Wzorzec Komunikacji:

**Frontend Service powinien:**
```typescript
@Injectable({ providedIn: 'root' })
export class RecipesService {
    private readonly supabase = inject(SupabaseService);

    // ✅ POPRAWNIE - wywołanie REST API
    getRecipes(params: GetRecipesParams): Observable<PaginatedResponseDto<RecipeListItemDto>> {
        const queryParams = new URLSearchParams();
        // ... budowanie query params

        return from(
            this.supabase.functions.invoke<ResponseType>(
                `recipes?${queryParams.toString()}`,
                { method: 'GET' }
            )
        ).pipe(
            map(response => {
                if (response.error) throw new Error(response.error.message);
                return response.data ?? defaultValue;
            })
        );
    }

    // ❌ NIEPOPRAWNIE - bezpośrednie zapytanie do bazy
    // getRecipes(): Observable<Recipe[]> {
    //     return from(
    //         this.supabase.from('recipes').select('*')
    //     );
    // }
}
```

##### Wyjątki (Bardzo Rzadkie):

Jeśli absolutnie konieczne (np. prototypowanie, one-off scripts), **ZAWSZE**:
1. Dodaj komentarz `// TEMPORARY: Will be migrated to API`
2. Utwórz task/issue do migracji na API
3. Skonsultuj z zespołem przed merge

