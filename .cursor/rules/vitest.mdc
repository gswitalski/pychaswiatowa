## TESTING

### Guidelines for UNIT

#### VITEST

- Leverage the `vi` object for test doubles - Use `vi.fn()` for function mocks, `vi.spyOn()` to monitor existing functions, and `vi.stubGlobal()` for global mocks. Prefer spies over mocks when you only need to verify interactions without changing behavior.
- Create setup files for reusable configuration - Define global mocks, custom matchers, and environment setup in dedicated files referenced in your `vitest.config.ts`. This keeps your test files clean while ensuring consistent test environments.
- Monitor coverage with purpose and only when asked - Configure coverage thresholds in `vitest.config.ts` to ensure critical code paths are tested, but focus on meaningful tests rather than arbitrary coverage percentages.
- Make watch mode part of your workflow - Run `vitest --watch` during development for instant feedback as you modify code, filtering tests with `-t` to focus on specific areas under development.
- Explore UI mode for complex test suites - Use `vitest --ui` to visually navigate large test suites, inspect test results, and debug failures more efficiently during development.
- Configure jsdom for DOM testing - Set `environment: 'jsdom'` in your configuration for frontend component tests to enable realistic DOM manipulation and querying.
- Structure tests for maintainability - Group related tests with descriptive `describe` blocks, use explicit assertion messages, and follow the Arrange-Act-Assert pattern to make tests self-documenting.
- Leverage TypeScript type checking in tests - Enable strict typing in your tests to catch type errors early, and ensure mocks preserve the original type signatures for better type safety.

#### ANGULAR + VITEST

**Inicjalizacja środowiska testowego:**
- **Zawsze importuj Zone.js na początku plików testowych** - Dodaj `import 'zone.js'` i `import 'zone.js/testing'` jako pierwsze importy w każdym pliku testowym komponentów Angular. Pomimo globalnej konfiguracji w `test-setup.ts`, niektóre konfiguracje Vitest (np. `singleFork: true`) mogą wymagać lokalnych importów.
- **Inicjalizuj TestBed w beforeAll() dla izolowanych testów** - Gdy testujesz pojedyncze pliki lub napotykasz błąd "Need to call TestBed.initTestEnvironment() first", dodaj ręczną inicjalizację w `beforeAll()` z `TestBed.resetTestEnvironment()` i `TestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting())`.
- **Resetuj TestBed tylko gdy potrzebne** - Unikaj nadużywania `TestBed.resetTestingModule()` w `afterEach()`, ponieważ może to powodować problemy z inicjalizacją w kolejnych testach. Pozwól globalnej konfiguracji zarządzać cyklem życia.

**Testowanie komponentów z Angular Material:**
- **Zawsze importuj NoopAnimationsModule** - Dla komponentów wykorzystujących Angular Material dodaj `NoopAnimationsModule` do importów w `TestBed.configureTestingModule()` lub w funkcji `render()` z `@testing-library/angular`. Zapobiega to błędom związanym z animacjami w środowisku testowym.
- **Mockuj MatDialogRef i MAT_DIALOG_DATA dla dialogów** - Używaj `{ provide: MatDialogRef, useValue: { close: vi.fn() } }` i `{ provide: MAT_DIALOG_DATA, useValue: testData }` jako providerów. Pamiętaj o typowaniu mocków dla lepszej kontroli typu.

**Struktura testów Angular:**
- **Utwórz funkcję pomocniczą dla setupu komponentu** - Zamiast powielać konfigurację TestBed w każdym teście, stwórz funkcję pomocniczą `setupComponent()` lub `setupComponentWithData()`, która zwraca fixture, compiled HTML i mocki. Zwiększa to czytelność i redukuje duplikację kodu.
- **Używaj ComponentFixture.detectChanges() po interakcjach** - Po symulacji interakcji użytkownika (np. kliknięcia przycisku) zawsze wywołuj `fixture.detectChanges()` przed asercjami, aby zapewnić aktualizację widoku.
- **Preferuj selektory oparte na rolach i atrybutach Material** - Używaj selektorów takich jak `[mat-dialog-title]`, `mat-dialog-content` zamiast ogólnych selektorów CSS. Są bardziej odporne na zmiany struktury.

**Testowanie z @testing-library/angular:**
- **Używaj natywnych asercji Vitest zamiast custom matchers** - Matchery z `@testing-library/jest-dom` (jak `toBeInTheDocument()`, `toBeDisabled()`, `toHaveClass()`) mogą nie działać poprawnie z Vitest mimo instalacji pakietu. Zamiast tego używaj:
  - `expect(element).toBeTruthy()` zamiast `toBeInTheDocument()` (jeśli `getBy*` znajdzie element, jest w dokumencie)
  - `expect(element.hasAttribute('disabled')).toBe(true)` zamiast `toBeDisabled()`
  - `expect(element?.classList.contains('class-name')).toBe(true)` zamiast `toHaveClass()`
  - `expect(queryBy*(...)).toBeNull()` zamiast `not.toBeInTheDocument()`
- **Explicite określaj typy w FormBuilder** - Dla pustych tablic formularzy Angular używaj `fb.array<FormControl<string>>([])` zamiast `fb.array([])`. TypeScript nie potrafi wywnioskować typu pustej tablicy.
- **Używaj type assertions dla złożonych typów CDK** - Dla obiektów Drag & Drop z `@angular/cdk/drag-drop` używaj `as CdkDragDrop<T>` zamiast wielokrotnego `as any`. Importuj typy: `import type { CdkDragDrop } from '@angular/cdk/drag-drop'`.
- **Setup funkcja z @testing-library/angular** - Używaj funkcji `render()` z `@testing-library/angular` która zwraca `fixture`, `container`, `debug` i inne narzędzia:
```typescript
async function setupComponent(componentProperties = {}) {
    const user = userEvent.setup();
    const rendered = await render(MyComponent, {
        imports: [NoopAnimationsModule, /* other modules */],
        componentProperties: { /* props */ },
    });
    return { ...rendered, user };
}
```

**Testowanie standalone komponentów:**
- **Importuj komponenty bezpośrednio w imports** - Dla standalone komponentów Angular 14+ używaj `imports: [MyStandaloneComponent]` zamiast `declarations`. Vitest i TestBed obsługują to natywnie.
- **Pamiętaj o zależnościach komponentu** - Jeśli standalone komponent importuje inne moduły (np. `CommonModule`, `MatButtonModule`), upewnij się, że są one dostępne w konfiguracji testowej lub w importach samego komponentu.

**Testowanie serwisów Angular:**
- **Zawsze inicjalizuj TestBed z beforeAll()** - Dla testów serwisów, które napotykają błąd "Need to call TestBed.initTestEnvironment() first", dodaj w `beforeAll()`: `TestBed.resetTestEnvironment()` oraz `TestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting())`. Jest to wymagane w izolowanych testach serwisów.
- **Używaj async/await z firstValueFrom dla Observable** - Nie używaj `subscribe()` z callbackami w testach, ponieważ test może zakończyć się przed wykonaniem asercji. Zamiast tego konwertuj Observable na Promise: `const result = await firstValueFrom(service.method())`. Importuj `firstValueFrom` z `rxjs`.
- **Mockuj wszystkie zależności serwisu** - Twórz mocki dla wszystkich zależności (np. `HttpClient`, `SupabaseService`) używając `vi.fn()`. Przekazuj je przez providers w `TestBed.configureTestingModule()`. Resetuj mocki w `beforeEach()` używając `vi.clearAllMocks()`.
- **Używaj mockResolvedValue/mockReturnValue** - Dla asynchronicznych metod mockowych używaj `vi.fn().mockResolvedValue(value)`. Dla synchronicznych używaj `vi.fn().mockReturnValue(value)`. Dla Observable używaj `of()` z RxJS: `mockHttpClient.get.mockReturnValue(of(data))`.
- **Testuj zarówno ścieżki sukcesu jak i błędów** - Dla każdej metody serwisu testuj: (1) poprawne działanie, (2) obsługę błędów HTTP (`throwError(() => new HttpErrorResponse({...}))`), (3) przypadki brzegowe (brak sesji, puste odpowiedzi, null/undefined).
- **Weryfikuj wywołania mocków** - Sprawdzaj czy metody zostały wywołane z poprawnymi argumentami: `expect(mockService.method).toHaveBeenCalledWith(expectedArg)`. Sprawdzaj liczbę wywołań: `expect(mockService.method).toHaveBeenCalledTimes(1)`.
- **Kompiluj TestBed z await** - Używaj `await TestBed.configureTestingModule({...}).compileComponents()` w `beforeEach()`, nawet dla serwisów bez komponentów. To zapewnia pełną inicjalizację.

**Obsługa błędów w testach asynchronicznych:**
- **Użyj try-catch dla bardziej kontrolowanych asercji** - Gdy testujesz rzucanie błędów przez Observable, użyj try-catch zamiast tylko `rejects.toThrow()`, aby móc wykonać więcej asercji:
```typescript
try {
    await firstValueFrom(service.method());
    throw new Error('Test powinien rzucić błąd');
} catch (error: any) {
    expect(error.message).toBe('Expected error');
    expect(mockDependency.method).not.toHaveBeenCalled();
}
```
- **Testuj propagację błędów HTTP** - Sprawdzaj czy błędy HTTP są poprawnie propagowane: `await expect(() => firstValueFrom(service.method())).rejects.toMatchObject({ status: 500 })`.

**Debugowanie problemów:**
- **Sprawdź konfigurację pool w vitest.config.ts** - Jeśli napotykasz problemy z inicjalizacją TestBed, wypróbuj różne opcje: `pool: 'forks'` z `singleFork: true`, `pool: 'threads'` lub brak opcji pool. Angular TestBed może być wrażliwy na sposób izolacji testów.
- **Użyj verbose logging** - Przy trudnych do zdiagnozowania błędach uruchom testy z `--reporter=verbose` aby zobaczyć pełny stack trace i kolejność wykonywania hooków.
- **Jeśli testy przechodzą ale asercje się nie wykonują** - To oznaka asynchroniczności. Testy kończą się przed wykonaniem callbacków. Rozwiązanie: użyj `async/await` z `firstValueFrom()` zamiast `subscribe()`.
- **Sprawdź pokrycie kodu aby znaleźć niepokryte ścieżki** - Uruchom `npm run test:coverage -- nazwa-serwisu` aby zobaczyć które linie nie są pokryte testami. Dodaj testy dla alternatywnych ścieżek (np. odpowiedź bez zagnieżdżenia w pole `data`).

**Częste problemy i rozwiązania:**
- **Błąd "Cannot find package '@angular/animations'"** - Angular Material wymaga pakietu `@angular/animations`. Zainstaluj go: `npm install @angular/animations`.
- **Custom matchers nie działają** - Matchery z `@testing-library/jest-dom` mogą nie działać z Vitest. Używaj natywnych asercji Vitest (patrz sekcja "Testowanie z @testing-library/angular").
- **Błąd "Unable to perform pointer interaction as the element has 'pointer-events: none'"** - Element jest wyłączony (disabled). Nie próbuj klikać wyłączonych elementów. Sprawdź stan przed interakcją: `expect(button.hasAttribute('disabled')).toBe(true)`.
- **TypeScript błąd "Type 'FormArray<FormControl<unknown>>'"** - Explicite określ typ dla pustych tablic: `fb.array<FormControl<string>>([])`.
- **Linter warning "Unexpected any"** - W testach drag & drop użyj type assertions: `as CdkDragDrop<string[]>` zamiast `item: undefined as any`.
- **Błąd z tracking expression (NG0956)** - To ostrzeżenie Angular podczas testów drag & drop. Nie wpływa na testy, można je zignorować w kontekście testów jednostkowych.

**Przykład kompletnego testu serwisu:**
```typescript
import 'zone.js';
import 'zone.js/testing';
import { TestBed } from '@angular/core/testing';
import { BrowserDynamicTestingModule, platformBrowserDynamicTesting } from '@angular/platform-browser-dynamic/testing';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { describe, it, expect, vi, beforeEach, beforeAll } from 'vitest';
import { of, throwError, firstValueFrom } from 'rxjs';
import { MyService } from './my.service';
import { DependencyService } from './dependency.service';

describe('MyService', () => {
    let service: MyService;
    let mockHttpClient: any;
    let mockDependency: any;

    // Inicjalizacja środowiska testowego Angular
    beforeAll(() => {
        TestBed.resetTestEnvironment();
        TestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting());
    });

    beforeEach(async () => {
        // Przygotowanie mocków
        mockHttpClient = { get: vi.fn() };
        mockDependency = { getData: vi.fn() };

        // Konfiguracja TestBed
        await TestBed.configureTestingModule({
            providers: [
                MyService,
                { provide: HttpClient, useValue: mockHttpClient },
                { provide: DependencyService, useValue: mockDependency },
            ],
        }).compileComponents();

        service = TestBed.inject(MyService);
        vi.clearAllMocks();
    });

    describe('fetchData()', () => {
        it('powinien pobrać dane z API', async () => {
            // Arrange
            const mockData = { id: 1, name: 'Test' };
            mockHttpClient.get.mockReturnValue(of(mockData));

            // Act
            const result = await firstValueFrom(service.fetchData());

            // Assert
            expect(result).toEqual(mockData);
            expect(mockHttpClient.get).toHaveBeenCalledWith('/api/data');
        });

        it('powinien propagować błąd HTTP', async () => {
            // Arrange
            const httpError = new HttpErrorResponse({ status: 500 });
            mockHttpClient.get.mockReturnValue(throwError(() => httpError));

            // Act & Assert
            await expect(() => firstValueFrom(service.fetchData())).rejects.toMatchObject({ status: 500 });
        });

        it('powinien rzucić błąd przy braku zależności', async () => {
            // Arrange
            mockDependency.getData.mockReturnValue(null);

            // Act & Assert
            try {
                await firstValueFrom(service.fetchData());
                throw new Error('Test powinien rzucić błąd');
            } catch (error: any) {
                expect(error.message).toBe('Brak danych z zależności');
                expect(mockHttpClient.get).not.toHaveBeenCalled();
            }
        });
    });
});
```

**Przykład kompletnego testu komponentu z @testing-library/angular:**
```typescript
import 'zone.js';
import 'zone.js/testing';
import { describe, it, expect, beforeAll, beforeEach } from 'vitest';
import { TestBed } from '@angular/core/testing';
import { BrowserDynamicTestingModule, platformBrowserDynamicTesting } from '@angular/platform-browser-dynamic/testing';
import { render, screen } from '@testing-library/angular';
import userEvent from '@testing-library/user-event';
import { FormArray, FormBuilder, FormControl } from '@angular/forms';
import { NoopAnimationsModule } from '@angular/platform-browser/animations';
import type { CdkDragDrop } from '@angular/cdk/drag-drop';
import { MyComponent } from './my.component';

describe('MyComponent', () => {
    let fb: FormBuilder;

    beforeAll(() => {
        TestBed.resetTestEnvironment();
        TestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting());
    });

    beforeEach(() => {
        fb = new FormBuilder();
    });

    async function setupComponent(componentProperties = {}) {
        const user = userEvent.setup();
        const rendered = await render(MyComponent, {
            imports: [NoopAnimationsModule],
            componentProperties: {
                formArray: fb.array<FormControl<string>>([
                    fb.control('Item 1', { nonNullable: true })
                ]),
                ...componentProperties,
            },
        });
        return { ...rendered, user };
    }

    it('powinien wyrenderować element', async () => {
        // Arrange & Act
        await setupComponent();

        // Assert
        expect(screen.getByText('Item 1')).toBeTruthy();
    });

    it('powinien dodać element po kliknięciu', async () => {
        // Arrange
        const formArray = fb.array<FormControl<string>>([]);
        const { user } = await setupComponent({ formArray });

        // Act
        const input = screen.getByPlaceholderText('Add item');
        await user.type(input, 'New item');

        const addButton = screen.getByRole('button', { name: /Add/i });
        await user.click(addButton);

        // Assert
        expect(formArray.length).toBe(1);
        expect(formArray.at(0).value).toBe('New item');
        expect(screen.getByText('New item')).toBeTruthy();
    });

    it('powinien obsłużyć drag & drop', async () => {
        // Arrange
        const formArray = fb.array([
            fb.control('A', { nonNullable: true }),
            fb.control('B', { nonNullable: true }),
        ]);
        const { fixture } = await setupComponent({ formArray });

        // Act
        const component = fixture.componentInstance;
        component.drop({
            previousIndex: 0,
            currentIndex: 1,
            isPointerOverContainer: true,
            distance: { x: 0, y: 0 },
            dropPoint: { x: 0, y: 0 },
            event: new MouseEvent('mouseup'),
        } as CdkDragDrop<string[]>);
        fixture.detectChanges();

        // Assert
        expect(formArray.at(0).value).toBe('B');
        expect(formArray.at(1).value).toBe('A');
    });
});
```

